{
  "data_quality": {
    "rules": [
      {
        "column": "__TABLE__",
        "rule_type": "pk",
        "condition": "emp_id",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "The 'emp_id' column must be unique across all rows. Based on 'primary_key: true' flag. This is an aggregate check performed post-load.",
        "spark_exp": "true"
      },
      {
        "column": "__TABLE__",
        "rule_type": "fk",
        "condition": "dept_id references department(dept_id)",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Each non-null 'dept_id' must exist in the referenced department table. This is an aggregate check performed post-load.",
        "spark_exp": "true"
      },
      {
        "column": "__TABLE__",
        "rule_type": "custom_sql",
        "condition": "ROW_COUNT > 0",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "The table should not be empty after loading.",
        "spark_exp": "true"
      },
      {
        "column": "emp_id",
        "rule_type": "not_null",
        "condition": null,
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Employee ID must not be null, as it is the primary key. Based on 'nullable: false' and comment.",
        "spark_exp": "emp_id IS NOT NULL"
      },
      {
        "column": "emp_id",
        "rule_type": "min",
        "condition": "1",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Employee ID should be a positive integer.",
        "spark_exp": "emp_id > 0"
      },
      {
        "column": "emp_name",
        "rule_type": "not_empty",
        "condition": null,
        "severity": "WARNING",
        "action": "WARN",
        "description": "If an employee name is provided, it must not be an empty or whitespace-only string.",
        "spark_exp": "emp_name IS NULL OR length(trim(emp_name)) > 0"
      },
      {
        "column": "dept_id",
        "rule_type": "custom_sql",
        "condition": "Value must be a positive integer if not null.",
        "severity": "WARNING",
        "action": "WARN",
        "description": "If a department ID is provided, it must be a positive integer.",
        "spark_exp": "dept_id IS NULL OR dept_id > 0"
      },
      {
        "column": "salary",
        "rule_type": "min",
        "condition": "0",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Salary, if present, must be a non-negative value. This is a PII column.",
        "spark_exp": "salary IS NULL OR salary >= 0"
      },
      {
        "column": "joining_date",
        "rule_type": "not_null",
        "condition": null,
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Joining date must not be null. This rule is based on the business context in the comments ('there will be no employee without a joining date'), which overrides the 'nullable: true' schema property.",
        "spark_exp": "joining_date IS NOT NULL"
      },
      {
        "column": "joining_date",
        "rule_type": "max",
        "condition": "current_date",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "The employee joining date cannot be in the future.",
        "spark_exp": "joining_date IS NULL OR joining_date <= current_date()"
      }
    ]
  },
  "tests": [
    {
      "name": "test_pk_uniqueness_emp_id",
      "sql": "SELECT emp_id, COUNT(*) FROM copilot_demo.employees WHERE emp_id IS NOT NULL GROUP BY emp_id HAVING COUNT(*) > 1",
      "description": "Ensures that there are no duplicate values in the primary key column 'emp_id'."
    },
    {
      "name": "test_not_null_emp_id",
      "sql": "SELECT COUNT(*) FROM copilot_demo.employees WHERE emp_id IS NULL",
      "description": "Verifies that the primary key column 'emp_id' contains no NULL values, expecting a count of 0."
    },
    {
      "name": "test_not_null_joining_date",
      "sql": "SELECT COUNT(*) FROM copilot_demo.employees WHERE joining_date IS NULL",
      "description": "Verifies that 'joining_date' contains no NULL values, based on business rule in comments. Expects a count of 0."
    },
    {
      "name": "test_future_joining_date",
      "sql": "SELECT COUNT(*) FROM copilot_demo.employees WHERE joining_date > current_date",
      "description": "Checks for any joining dates set in the future, expecting a count of 0."
    },
    {
      "name": "test_negative_salary",
      "sql": "SELECT COUNT(*) FROM copilot_demo.employees WHERE salary < 0",
      "description": "Ensures no employee has a negative salary value, expecting a count of 0."
    },
    {
      "name": "test_referential_integrity_dept_id",
      "sql": "/* Note: This test assumes a 'departments' table with a 'dept_id' column exists in the same database. */\nSELECT COUNT(t1.emp_id)\nFROM copilot_demo.employees AS t1\nLEFT JOIN copilot_demo.departments AS t2 ON t1.dept_id = t2.dept_id\nWHERE t1.dept_id IS NOT NULL AND t2.dept_id IS NULL",
      "description": "Checks for 'dept_id' values that do not have a corresponding entry in the departments table. Expects a count of 0."
    },
    {
      "name": "test_table_row_count",
      "sql": "SELECT CASE WHEN COUNT(*) > 0 THEN 0 ELSE 1 END FROM copilot_demo.employees",
      "description": "Checks that the table is not empty after load. Test fails if it returns 1."
    }
  ],
  "docs_markdown": "# Table: employees\n\n## Overview\nThis table contains information about employees in the organization.\n\n*   **Database:** `copilot_demo`\n*   **Table Name:** `employees`\n*   **Total Rows:** 414 (according to last stats)\n\n## Columns\n\n| Column Name  | Data Type | Nullable | Key / Index  | Description                                                     |\n|--------------|-----------|----------|--------------|-----------------------------------------------------------------|\n| `emp_id`     | `int`     | No       | Primary Key  | Unique identifier for each employee. Acts as the primary key.     |\n| `emp_name`   | `string`  | Yes      |              | The full name of the employee. (PII)                              |\n| `dept_id`    | `int`     | Yes      | Foreign Key  | Identifier for the employee's department. References departments table. |\n| `salary`     | `float`   | Yes      |              | The employee's salary. (PII)                                    |\n| `joining_date` | `date`    | Yes      |              | The date the employee joined the company. Business rule: cannot be null. |\n\n## Data Quality Summary\nThis table has several critical data quality rules enforced:\n- `emp_id` must be unique and not null.\n- `joining_date` must not be null and cannot be a future date, as per business requirements.\n- `salary` must be non-negative.\n- `dept_id` should correspond to a valid department.\n\n**Note**: Column statistics indicate potential data quality issues, such as nulls and duplicates in the `emp_id` column and nulls in the `joining_date` column, which violate the defined schema and business rules.",
  "suggestions": [
    {
      "area": "business_rule",
      "type": "SUGGESTION_ONLY",
      "description": "The 'dept_id' column is 100% NULL according to statistics. This may indicate a data pipeline issue or a business process change. Investigate why no employees are being assigned to a department.",
      "rule": {
        "column": "dept_id",
        "rule_type": "custom_sql",
        "condition": "NULL percentage should be below a certain threshold (e.g., 20%)",
        "severity": "WARNING",
        "action": "WARN",
        "description": "Monitors the percentage of nulls in 'dept_id' to detect upstream data source issues.",
        "spark_exp": "true",
        "sql_test": "SELECT (COUNT(CASE WHEN dept_id IS NULL THEN 1 END) * 100.0 / COUNT(*)) AS null_percentage FROM copilot_demo.employees HAVING null_percentage > 20",
        "notes": "The current 100% null rate is highly anomalous and should be investigated with business stakeholders."
      }
    },
    {
      "area": "governance",
      "type": "SUGGESTION_ONLY",
      "description": "The columns 'emp_name' and 'salary' contain Personally Identifiable Information (PII). Consider applying data masking or fine-grained access control (e.g., AWS Lake Formation) in downstream environments to protect sensitive data.",
      "rule": {
        "column": "emp_name, salary",
        "rule_type": "custom_sql",
        "condition": "Data must be masked or access-controlled",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Governance rule to ensure PII data is not exposed in non-production environments.",
        "spark_exp": "true",
        "sql_test": null,
        "notes": "This is a governance and security requirement, not a data quality check on the data content itself."
      }
    },
    {
      "area": "dq_rule",
      "type": "SUGGESTION_ONLY",
      "description": "Add a data freshness check to ensure the data is not stale. This can be based on the maximum 'joining_date'.",
      "rule": {
        "column": "__TABLE__",
        "rule_type": "custom_sql",
        "condition": "max(joining_date) should be within the last 30 days",
        "severity": "WARNING",
        "action": "WARN",
        "description": "Checks if the table is receiving recent data by verifying the latest joining date is recent.",
        "spark_exp": "true",
        "sql_test": "SELECT MAX(joining_date) FROM copilot_demo.employees HAVING MAX(joining_date) < date_add('day', -30, current_date)",
        "notes": "The threshold (e.g., 30 days) should be adjusted based on expected data ingestion frequency."
      }
    },
    {
      "area": "schema_design",
      "type": "SUGGESTION_ONLY",
      "description": "The source system is allowing NULLs and duplicates for 'emp_id', which is defined as the primary key. The root cause should be fixed in the source application or data generation process.",
      "rule": {
        "column": "emp_id",
        "rule_type": "pk",
        "condition": "Must be unique and not null at the source",
        "severity": "ERROR",
        "action": "FAIL_JOB",
        "description": "Enforce PK constraint at the source to prevent bad data from entering the data lake.",
        "spark_exp": "emp_id IS NOT NULL",
        "sql_test": null,
        "notes": "Fixing this at the source is more efficient than cleaning it in the data pipeline."
      }
    }
  ]
}